/**
 * Copyright (c) 2016, John Hewson
 * All rights reserved.
 */

export type ElmDecl = ElmType | ElmTypeAlias | ElmFunction;

export interface ElmType {
  name: string;
  constructors: Array<string>;
}

export interface ElmTypeAlias {
  name: string;
  fields: Array<ElmField>;
}

export type ElmField = ElmRecordField | ElmLeafField;

export interface ElmRecordField {
  name: string;
  fields: Array<ElmField>;
  list?: boolean;  // hack
}

export interface ElmLeafField {
  name: string;
  type: string;
}

export interface ElmFunction {
  name: string;
  parameters: Array<ElmParameter>;
  returnType: string;
  body: ElmExpr;
}

export interface ElmParameter {
  name: string;
  type: string;
}

export interface ElmExpr {
  expr: string; // todo: expression trees
}

export function moduleToElm(name: string, expose: Array<string>, imports: Array<string>,
                            decls: Array<ElmDecl>) {
  let warn = '{-\n    This file is automatically generated by elm-graphql. Do not modify!\n-}\n';
  return warn + 'module ' + name + ' exposing (' + expose.join(', ') + ')\n' +
    imports.map(str => '\nimport ' + str).join('') + '\n\n' +
    decls.map(declToElm).join('\n\n');
}

export function declToElm(decl: ElmDecl): string {
  if ((<ElmType>decl).constructors) {
    return typeToElm(<ElmType>decl);
  } else if ((<ElmFunction>decl).returnType) {
    return functionToElm(<ElmFunction>decl);
  } else {
    return aliasToElm(<ElmTypeAlias>decl);
  }
}

export function typeToElm(type: ElmType): string {
  return 'type ' + type.name + '\n' +
    '    = ' + type.constructors.join('\n    | ') + '\n';
}

export function aliasToElm(type: ElmTypeAlias): string {
  return 'type alias ' + type.name + ' =\n' +
    '    { ' + type.fields.map(f => fieldToElm(f, 1)).join('\n    , ') + '    }\n';
}

export function functionToElm(func: ElmFunction): string {
  let paramTypes = func.parameters.map(p => p.type).join(' -> ');
  let paramNames = func.parameters.map(p => p.name).join(' ');
  let arrow = paramTypes.length > 0 ? ' -> ' : '';
  let space = paramTypes.length > 0 ? ' ' : '';
  return func.name + ' : ' + paramTypes + arrow + func.returnType + '\n' +
         func.name + space + paramNames + ' =\n    ' + exprToElm(func.body, 0) + '\n';
}

function fieldToElm(field: ElmField, level: number): string {
  if ((<ElmLeafField>field).type) {
    return leafToElm(<ElmLeafField>field);
  } else {
    return recordToElm(<ElmRecordField>field, level + 1);
  }
}

function recordToElm(record: ElmRecordField, level: number): string {
  let indent = makeIndent(level);
  let list = record.list ? 'List ' : '';
  let type = `${indent}${list}{ ` +
              record.fields.map(f => fieldToElm(f, level)).join(`${indent}, `) +
              `${indent}}`;
  return record.name + ' :\n' + type + '\n';
}

function leafToElm(field: ElmLeafField): string {
  return field.name + ' : ' + field.type + '\n';
}

function makeIndent(level: number) {
  let str = '';
  for (let i = 0; i < level; i++) {
    str += '    ';
  }
  return str;
}

export function exprToElm(expr: ElmExpr, level: number): string {
  return expr.expr; // todo: expression trees
}
